#!/bin/bash
# Dumps PS4 games via FTP connection over the network.
# Requires cURL and a PS4 FTP server that supports SELF decryption.
# For maximum speed, a gigabit cable connection is recommended.
# Please report bugs at https://github.com/hippie68/ftpdump/issues.

# Optional default values: #####################################################

# PS4's IP address
ip=
# PS4's FTP port (FTP payload: 1337)
port=
# Beep when done
beep=false
# How long to beep, in seconds
beep_time=60
# How frequently to beep, in seconds
beep_interval=3

# Functions: ###################################################################

print_usage() {
  echo "Usage: ${0##*/} [OPTIONS] HOSTNAME|IP_ADDRESS[:PORT] [OUTPUT_DIRECTORY]"
  echo
  echo "1) Insert a disc and install the game. Optional: visit orbispatches.com"
  echo "   to download and install a game patch compatible with your firmware."
  echo "2) Start the FTP server payload on your PS4."
  echo "3) Press the PS button (no other button) to leave the browser."
  echo "4) Run the game."
  echo "5) Run this script."
  echo
  echo "To dump more games, repeat steps 1), 4), 5)."
  echo
  echo "Before running the script, make sure the game is completely installed."
  echo "Should the dumping process be interrupted, please delete partial dumps"
  echo "before trying again."
  echo
  echo "Options:"
  echo "  -a, --app       Dump app data."
  echo "  -d, --dlc       Dump DLC data."
  echo "  -h, --help      Print usage information."
  echo "  -k, --keystone  Dump original keystone."
  echo "  -p, --patch     Dump patch data."
  echo "  -s, --sflash    Dump sflash0 file and quit."
}

debug_message() {
  if [[ $DEBUG ]]; then
    echo "DEBUG: $1" >&2
  fi
}

# Parses command line arguments, creating C-like argc and argv; called with $@
build_args() {
  argc=0
  while [[ $1 != "--" && $1 != "" ]]; do
    if [[ $1 == --* ]]; then
      argv[argc++]=$1
    elif [[ $1 == -?* ]]; then
      for ((i = 1; i < ${#1}; i++)); do
        argv[argc++]=-${1:i:1}
      done
    else
      argv[argc++]=$1
    fi
    shift
  done
  while [[ $1 != "" ]]; do
    argv[argc++]=$1
    shift
  done
  debug_message "Expanded arguments: ${argv[*]}"
}

# Kills the script with an optional message $1
abort() {
  if [[ $1 != "" ]]; then
    echo "$1" >&2
  fi
  echo "Error encountered, script aborted." >&2
  exit 1
}

curl_error() {
  abort "cURL reported error $? (see https://curl.se/libcurl/c/libcurl-errors.html)."
}

# Portable replacement for GNU realpath
realpath() {
  echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
}

# Downloads a single FTP file $1, overwriting existing files
# (optional: $2: bytes to skip, $3: bytes to download)
dump_file() {
  local new_file=${1##*/}

  echo "$new_file"

  if [[ $2 != "" ]]; then
    curl $curl_verbose --silent --ignore-content-length "$1" \
      | dd "$dd_options" skip="$2" count="$3" 2> /dev/null > "$new_file" || \
      curl_error
  else
    curl $curl_verbose --silent --ignore-content-length "$1" \
      --output "$new_file" || curl_error
  fi
}

# Recursively downloads an FTP directory (this functionality is missing in cURL)
dump_dir() {
  local line
  local new_dir

  while read line; do
    debug_message "FTP directory entry: $line"
    # Recurse directories
    if [[ $line == d* ]]; then
      new_dir=${line##* }
      if [[ $new_dir != . && $new_dir != .. ]]; then # Skip . and .. directories
        echo "$new_dir/"
        mkdir --parents "$new_dir" && cd "$new_dir" || abort
        dump_dir "$1$new_dir/"
        cd .. || abort
      fi
    # Download files
    elif [[ $line == -* ]]; then
      dump_file "$1/${line##* }"
    fi
  done < <(curl --silent "$1")
}

# Enables SELF decryption, which the FTP server must support
enable_decryption() {
  curl -v --silent --quote DECRYPT "$root" 2>&1 \
    | grep "SELF decryption enabled" > /dev/null
  if [[ $? != 0 ]]; then
    curl -v --silent --quote DECRYPT "$root" 2>&1 \
      | grep "SELF decryption enabled" > /dev/null
    if [[ $? != 0 ]]; then
      echo "Could not enable decryption. Please try a different FTP server." >&2
      exit 1
    fi
  fi
}

# PKG extraction: --------------------------------------------------------------

# Returns a 4-byte integer, read from file $1 at offset $2 in big-endian
read_integer() {
  local result=0
  local byte
  local i

  for i in {0..3}; do
    IFS= read -rd "" byte < <(dd bs=1 count=1 skip=$(($2 + i)) if="$1" \
      2> /dev/null)
    byte=$(printf "%d" "'$byte")
    result=$((result + 256 ** (3 - i) * byte))
  done

  echo $result
}

# Returns a string, read from file $1 at offset $2
read_string() {
  local result
  local byte
  local i=0

  while true; do
    IFS= read -rd "" byte < <(dd bs=1 count=1 skip=$(($2 + i)) if="$1" \
      2> /dev/null)
    if [[ $(printf "%d" "'$byte") != 0 ]]; then
      result+=$byte
    else
      break
    fi
    ((i++))
  done

  echo "$result"
}

# Extracts a single file from PKG file $1
# $2: offset, $3: size, $4: output file name
extract_pkg_file() {
  echo "$4"
  if [[ $4 == */* ]]; then # Create directory, if necessary
    mkdir -p "${4%/*}"
  fi
  dd if="$1" "$dd_options" skip="$2" count="$3" 2> /dev/null > "$4" || abort \
    "Could not extract file \"$4\"."
}

# Extracts all files from PKG file $1
extract_pkg() {
  local file_table_offset=$(read_integer "$1" $((0x18)))
  local file_count=$(read_integer "$1" $((0x10)))
  local offset=$file_table_offset
  local id
  local filename_offset
  local data_offset
  local size
  local filename
  local unknown_count

  # Loop through all entries
  local i=0
  while [[ $i -lt $file_count ]]; do
    id=$(read_integer "$1" offset)
    filename_offset=$(read_integer "$1" $((offset + 4)))
    data_offset=$(read_integer "$1" $((offset + 16)))
    size=$(read_integer "$1" $((offset + 20)))
    if [[ $id == 512 ]]; then
      filename_table_offset=$data_offset
    fi

    # Extract entries that are files
    if [[ $id -ge 1024 ]]; then
      # For files that have no name, create file names
      if [[ $id -lt 4096 ]]; then
        case $id in
          1024) filename=license.dat ;; # 0x400
          1025) filename=license.info ;;
          1026) filename=nptitle.dat ;;
          1027) filename=npbind.dat ;;
          1028) filename=selfinfo.dat ;;
          1030) filename=imageinfo.dat ;;
          1031) filename=target-deltainfo.dat ;;
          1032) filename=origin-deltainfo.dat ;;
          1033) filename=psreserved.dat ;;
             *) filename=UNKNOWN_$((unknown_count++))
                printf "Warning: No file name known for file ID \"%#x\".\n" $id >&2
                printf "         Using file name \"%s\".\n" "$filename" >&2
                ;;
        esac
      # For other files, read existing file names
      elif [[ $filename_table_offset && $filename_offset -gt 0 ]]; then
        filename=$(read_string "$1" $((filename_table_offset + filename_offset)))
      fi
      # Extract file
      if [[ ! -e "$filename" ]]; then
        extract_pkg_file "$1" $data_offset $size "$filename"
      else
        debug_message "Warning: File already exists: \"$filename\" (skipped)"
      fi
    fi

    debug_message "$(printf "ID: %#x\n" $id)"
    debug_message "Filename offset: $filename_offset"
    debug_message "Data offset: $data_offset"
    debug_message "Size: $size"

    ((i++))
    ((offset += 32))
  done
}

dump_and_extract_pkg() {
  local pkg_filename=${1##*/}

  # Test how much PKG data should be downloaded
  debug_message "Dumping 48 bytes from $pkg_filename to get body size"
  dump_file "$1" 0 48 > /dev/null
  body_offset=$(read_integer "$pkg_filename" 36)
  debug_message "Body offset: $body_offset"
  body_size=$(read_integer "$pkg_filename" 44)
  debug_message "Body size: $body_size"

  # Download PKG body and extract PKG files
  debug_message "Dumping body from $pkg_filename ($((body_offset + body_size)) bytes)"
  dump_file "$1" 0 $((body_offset + body_size))
  extract_pkg "$pkg_filename"

  rm "$pkg_filename" || abort \
    "Could not remove temporary file \"$pkg_filename\"."
}

# Main script: #################################################################

LC_ALL=C

if [[ $CURL_VERBOSE ]]; then
  curl_verbose="-v"
fi

build_args "$@"

# Get options
for ((i = 0; i < argc; i++)); do
  if [[ $no_more_args ]]; then
    non_options[noptc++]=${argv[i]}
  else
    case ${argv[i]} in
      --) no_more_args=1 ;;
      -a|-g|--app|--game|--app-only) dump_app=1 ;;
      -d|--dlc|--dlc-only) dump_dlc=1 ;;
      -h|--help) print_usage; exit 0 ;;
      -k|--keystone) dump_keystone=1 ;;
      -p|--patch|--patch-only) dump_patch=1 ;;
      -s|--sflash|--sflash0) dump_sflash=1 ;;
      -*) echo "Unknown option: ${argv[i]}" >&2; print_usage >&2; exit 1 ;;
      *) non_options[noptc++]=${argv[i]} ;;
    esac
  fi
done

# Dump everything by default
if [[ ! $dump_app$dump_patch$dump_dlc$dump_keystone$dump_sflash ]]; then
  dump_app=1 dump_patch=1 dump_dlc=1
fi
debug_message "Dump options: dump_app=$dump_app, dump_patch=$dump_patch, \
dump_dlc=$dump_dlc, dump_keystone=$dump_keystone, dump_sflash=$dump_sflash"

# Set FTP prefix
if [[ ${non_options[0]} ]]; then
  ip=${non_options[0]%:*}
fi
if [[ ${non_options[0]} == *:* ]]; then
  port=${non_options[0]#*:}
fi
if [[ ! $port ]]; then
  port=1337
fi
if [[ ! $ip ]]; then
  echo "Please specify an IP address." >&2
  print_usage >&2
  exit 1
fi
root="ftp://$ip:$port"
debug_message "Using FTP server \"$root\""

# Set output directory
if [[ ${non_options[1]} ]]; then
  output_dir=$(realpath "${non_options[1]}")
else
  output_dir=$(realpath .)
fi
debug_message "Using output directory \"$output_dir\""

# Exit if FTP server is not running
curl --silent --head "$root/" > /dev/null
case $? in
  0) ;;
  6) abort "Could not resolve host \"$ip\". Please fix your computer's and/or router's DNS settings or enter an IP address." ;;
  7) abort "Could not connect to FTP server. Is it running, and are IP address and port correct?" ;;
  *) curl_error ;;
esac

enable_decryption

# Get Title ID
if [[ ! $dump_sflash ]]; then
  title_id=$(curl --silent "$root/mnt/sandbox/" | grep -E " CUSA[0-9]{5}_")
  title_id=${title_id##* }
  title_id=${title_id%_*}
  if [[ $title_id != CUSA[0-9][0-9][0-9][0-9][0-9] ]]; then
    echo "Could not retreive Title ID. Is the game started?" >&2
    exit 1
  fi
fi

# Set dd options
dd --version | grep GNU > /dev/null
if [[ $? == 0 ]]; then
  dd_options="iflag=skip_bytes,count_bytes" # For GNU dd; much faster
else
  dd_options="ibs=1"
fi

mkdir --parents "$output_dir" || abort

# Dump sflash0 -----------------------------------------------------------------

if [[ $dump_sflash ]]; then
  cd "$output_dir" || abort
  dump_file "$root/dev/sflash0"
  exit 0
fi

# Dump keystone ----------------------------------------------------------------

if [[ $dump_keystone ]]; then
  cd "$output_dir" || abort
  echo "Dumping $title_id keystone:"
  mkdir --parents "$title_id-keystone" && cd "$title_id-keystone" || abort

  dump_file "$root/mnt/sandbox/pfsmnt/$title_id-app0/sce_sys/keystone"
fi

# Dump app data ----------------------------------------------------------------

if [[ $dump_app ]]; then
  cd "$output_dir" || abort
  echo "Dumping $title_id app data:"
  mkdir --parents "$title_id-app" && cd "$title_id-app" || abort

  dump_dir "$root/mnt/sandbox/pfsmnt/$title_id-app0/"

  mkdir --parents sce_sys && cd sce_sys || abort
  dump_file "$root/System_data/priv/appmeta/$title_id/npbind.dat"
  dump_file "$root/System_data/priv/appmeta/$title_id/nptitle.dat"

  dump_and_extract_pkg "$root/user/app/$title_id/app.pkg"
fi

# Dump patch data --------------------------------------------------------------

if [[ $dump_patch ]]; then
  debug_message "Checking if patch data exists"
  curl --silent --head "$root/mnt/sandbox/pfsmnt/$title_id-patch0/" > /dev/null
  if [[ $? == 0 ]]; then
    cd "$output_dir" || abort
    echo "Dumping $title_id patch data:"
    mkdir --parents "$title_id-patch" && cd "$title_id-patch" || abort

    dump_dir "$root/mnt/sandbox/pfsmnt/$title_id-patch0/"

    mkdir --parents sce_sys && cd sce_sys || abort
    dump_file "$root/System_data/priv/appmeta/$title_id/npbind.dat"
    dump_file "$root/System_data/priv/appmeta/$title_id/nptitle.dat"

    dump_and_extract_pkg "$root/user/patch/$title_id/patch.pkg"
  else
    echo "No patch data found."
  fi
fi

# Dump DLC ---------------------------------------------------------------------

if [[ $dump_dlc ]]; then
  debug_message "Checking if DLC data exists"
  unset dlc_dirs
  while read line; do
    if [[ $line == d*$title_id*-ac ]]; then
      debug_message "Found DLC directory ${line##* }"
      dlc_dirs+="${line##* } "
    fi
  done < <(curl --silent "$root/mnt/sandbox/pfsmnt/")

  if [[ $dlc_dirs ]]; then
    cd "$output_dir" || abort
    echo "Dumping $title_id DLC data:"
    mkdir --parents "$title_id-dlc" && cd "$title_id-dlc" || abort
    for dir in $dlc_dirs; do
      mkdir "$dir" && cd "$dir" || abort
      dump_dir "$root/mnt/sandbox/pfsmnt/$dir/"
      cd .. || abort
    done
  else
    echo "No DLC data found."
  fi
fi

#-------------------------------------------------------------------------------

echo "Done."

# Beep when done
if [[ $beep == true ]]; then
  echo "Press CTRL-C to stop beeping."
  if [[ ! $beep_time ]]; then
    beep_time=60
  fi
  if [[ ! $beep_interval ]]; then
    beep_interval=3
  fi
  i=0
  while [[ $i -le $beep_time ]]; do
    echo -en "\a"
    sleep $beep_interval
    ((i += beep_interval))
  done
fi
